<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D 打驢子遊戲</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Noto Sans TC', sans-serif;
            margin: 0;
            overflow: hidden; /* 隱藏滾動條 */
        }
        #ui-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* 讓滑鼠可以穿透 UI 層點擊 3D 物件 */
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
        }
        .ui-element {
            pointer-events: auto; /* 讓 UI 元素可以被點擊 */
        }
        .score-updated {
            display: inline-block;
            animation: score-update-animation 0.3s ease-in-out;
        }
        @keyframes score-update-animation {
            0% { transform: scale(1); }
            50% { transform: scale(1.3); color: #FFD700; }
            100% { transform: scale(1); }
        }
        #end-game-modal {
            pointer-events: auto;
        }
        @keyframes fade-in-up {
            from { opacity: 0; transform: translateY(20px) scale(0.95); }
            to { opacity: 1; transform: translateY(0) scale(1); }
        }
        .animate-fade-in-up {
            animation: fade-in-up 0.5s forwards ease-out;
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
            display: block;
            /* 隱藏系統滑鼠游標 */
            cursor: none;
        }
        #boss-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 3rem;
            font-weight: bold;
            text-shadow: 2px 2px 8px black;
            opacity: 0;
            transition: opacity 0.5s;
            pointer-events: none;
        }
        #mutation-status {
            transition: all 0.3s;
        }
        button:disabled {
            background-color: #9CA3AF;
            cursor: not-allowed;
        }
    </style>
</head>
<body class="bg-gray-800">

    <div id="canvas-container"></div>

    <div id="ui-container" class="p-4 md:p-8">
        <!-- 標題和分數板 -->
        <header class="text-center bg-black bg-opacity-25 p-4 rounded-xl ui-element w-full max-w-md">
            <h1 class="text-3xl md:text-4xl font-bold text-white">3D 打驢子遊戲</h1>
            <div class="flex justify-around mt-4 text-xl font-bold text-white gap-x-8">
                <p>分數: <span id="score" class="p-2 bg-green-600 rounded-lg">0</span></p>
                <p>時間: <span id="time-left" class="p-2 bg-red-500 rounded-lg">60</span></p>
            </div>
            <div id="mutation-status" class="text-xl md:text-2xl font-bold text-yellow-300 text-center ui-element mt-4 p-2 rounded-lg">等待變異...</div>
        </header>

         <div id="boss-message">驢子騷味來襲！</div>

        <!-- 控制按鈕 -->
        <footer class="text-center mb-8 ui-element flex gap-4">
            <button id="start-button" class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-3 px-8 rounded-full text-2xl transition duration-300 transform hover:scale-105 shadow-lg">
                開始遊戲
            </button>
            <button id="upgrade-button" class="bg-purple-600 hover:bg-purple-800 text-white font-bold py-3 px-6 rounded-full text-xl transition duration-300 transform hover:scale-105 shadow-lg hidden">
                高級驢子 (50分)
            </button>
        </footer>
    </div>

    <!-- 遊戲結束畫面 (Modal) -->
    <div id="end-game-modal" class="hidden fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50">
        <div class="bg-white p-8 rounded-2xl text-center shadow-xl transform transition-all scale-95 opacity-0 animate-fade-in-up">
            <h2 class="text-4xl font-bold mb-4 text-gray-800">遊戲結束！</h2>
            <p class="text-2xl mb-6 text-gray-600">你的最終分數是：</p>
            <p id="final-score" class="font-bold text-7xl text-blue-600 mb-8">0</p>
            <button id="restart-button" class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-3 px-10 rounded-full text-2xl transition duration-300 transform hover:scale-105 shadow-lg">
                重新開始
            </button>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.164.1/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- UI DOM 元素 ---
        const scoreDisplay = document.getElementById('score');
        const timeLeftDisplay = document.getElementById('time-left');
        const startButton = document.getElementById('start-button');
        const upgradeButton = document.getElementById('upgrade-button');
        const endGameModal = document.getElementById('end-game-modal');
        const finalScoreDisplay = document.getElementById('final-score');
        const restartButton = document.getElementById('restart-button');
        const canvasContainer = document.getElementById('canvas-container');
        const bossMessage = document.getElementById('boss-message');
        const mutationStatusDisplay = document.getElementById('mutation-status');

        // --- 遊戲變數 ---
        let score = 0;
        let timeLeft = 60;
        let gameTimerId = null;
        let animalTimerId = null;
        let isGameRunning = false;
        let isBossActive = false;
        
        // 變異系統變數
        const mutations = ['加速!', '縮小!', '變色!', '騷味來襲!'];
        let popInterval = 1500;
        let popDurationMin = 800;
        let popDurationMax = 1000;
        const defaultScale = 1.0;

        // 高級驢子變數
        const UPGRADE_COST = 50;
        let isAdvancedModeActive = false;
        let advancedModeTimeoutId = null;

        // --- Three.js 變數 ---
        let scene, camera, renderer, controls, raycaster, pointer;
        const holePositions = [
            new THREE.Vector3(-10, 0, -10), new THREE.Vector3(0, 0, -10), new THREE.Vector3(10, 0, -10),
            new THREE.Vector3(-10, 0, 0),   new THREE.Vector3(0, 0, 0),   new THREE.Vector3(10, 0, 0),
            new THREE.Vector3(-10, 0, 10),  new THREE.Vector3(0, 0, 10),  new THREE.Vector3(10, 0, 10)
        ];
        const donkeys = [];
        let bossDonkey = null;
        const popHeight = 5;
        let hammer;
        let isSwinging = false;
        let swingProgress = 0;
        let dustEffects = [];

        // --- Helper functions ---
        function createGrassTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const context = canvas.getContext('2d');
            context.fillStyle = '#284d1a'; // 深草綠色基底
            context.fillRect(0, 0, 256, 256);
            for (let i = 0; i < 10000; i++) {
                const x = Math.random() * 256;
                const y = Math.random() * 256;
                const shade = Math.random() > 0.5 ? '#3a6928' : '#4b8235'; // 較淺的草色斑點
                context.fillStyle = shade;
                context.fillRect(x, y, 2, 2);
            }
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(20, 20); // 重複紋理
            return texture;
        }


        // --- 初始化函式 ---
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 35, 65);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 25, 25);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            canvasContainer.appendChild(renderer.domElement);
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.target.set(0, 0, 0);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
            directionalLight.position.set(20, 30, 15);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 80;
            directionalLight.shadow.camera.left = -30;
            directionalLight.shadow.camera.right = 30;
            directionalLight.shadow.camera.top = 30;
            directionalLight.shadow.camera.bottom = -30;
            scene.add(directionalLight);

            const groundGeometry = new THREE.PlaneGeometry(100, 100);
            const groundMaterial = new THREE.MeshStandardMaterial({ map: createGrassTexture() });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.receiveShadow = true;
            ground.rotation.x = -Math.PI / 2;
            scene.add(ground);

            const holeMaterial = new THREE.MeshStandardMaterial({ color: 0x3d2817 });
            holePositions.forEach(pos => {
                const holeGeometry = new THREE.CylinderGeometry(2, 2, 0.2, 32);
                const hole = new THREE.Mesh(holeGeometry, holeMaterial);
                hole.position.copy(pos);
                hole.position.y = 0.01;
                scene.add(hole);
            });

            holePositions.forEach(pos => {
                const donkey = createDonkey();
                donkey.position.copy(pos);
                donkey.position.y = -popHeight;
                donkey.userData.isUp = false;
                donkey.userData.timeoutId = null;
                donkeys.push(donkey);
                scene.add(donkey);
            });
            bossDonkey = createDonkey(true);
            bossDonkey.position.y = -popHeight * 2;
            scene.add(bossDonkey);

            // 創建 3D 槌子
            hammer = createHammer();
            scene.add(hammer);
            
            raycaster = new THREE.Raycaster();
            pointer = new THREE.Vector2();

            // 事件監聽
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('mousemove', onPointerMove);
            window.addEventListener('mousedown', onPointerDown);
            startButton.addEventListener('click', startGame);
            restartButton.addEventListener('click', startGame);
            upgradeButton.addEventListener('click', buyUpgrade);
            animate();
        }
        
        function createHammer() {
            const group = new THREE.Group();

            const handleMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.8 });
            const headMaterial = new THREE.MeshStandardMaterial({ color: 0x959595, metalness: 0.8, roughness: 0.3 });

            const handleGeom = new THREE.CylinderGeometry(0.15, 0.2, 3, 12);
            const handle = new THREE.Mesh(handleGeom, handleMaterial);
            handle.position.y = -1.5;
            handle.castShadow = true;
            group.add(handle);

            const headGeom = new THREE.BoxGeometry(1.5, 1, 1);
            const head = new THREE.Mesh(headGeom, headMaterial);
            head.position.y = 0;
            head.castShadow = true;
            group.add(head);

            group.scale.set(1.5, 1.5, 1.5);
            return group;
        }

        function createDonkey(isBoss = false) {
            const group = new THREE.Group();
            group.name = isBoss ? "bossDonkey" : "donkey";
            const bodyMaterial = new THREE.MeshStandardMaterial({ color: isBoss ? 0xFFD700 : 0x967969 });
            const snoutMaterial = new THREE.MeshStandardMaterial({ color: isBoss ? 0xFFF5B3 : 0xBDB1A6 });
            const eyeMaterial = new THREE.MeshStandardMaterial({ color: isBoss ? 0xFF0000 : 0x111111 });
            const maneMaterial = new THREE.MeshStandardMaterial({ color: isBoss ? 0xDAA520 : 0x4B3A2E });
            
            const materials = [bodyMaterial, snoutMaterial, eyeMaterial, maneMaterial];
            materials.forEach(mat => {
                 mat.userData = { originalColor: mat.color.clone() };
            });

            const headGeometry = new THREE.CylinderGeometry(1, 1.5, 2.5, 16);
            const head = new THREE.Mesh(headGeometry, bodyMaterial);
            head.castShadow = true;
            head.position.y = 1.25;
            group.add(head);

            const snoutGeometry = new THREE.SphereGeometry(1, 16, 8);
            const snout = new THREE.Mesh(snoutGeometry, snoutMaterial);
            snout.position.set(0, 0.8, 1);
            snout.scale.set(0.8, 0.8, 1.1);
            snout.castShadow = true;
            group.add(snout);

            const nostrilGeometry = new THREE.SphereGeometry(0.1, 8, 8);
            const nostrilMaterial = new THREE.MeshStandardMaterial({ color: 0x4b3a2e });
            const leftNostril = new THREE.Mesh(nostrilGeometry, nostrilMaterial);
            leftNostril.position.set(-0.4, 0.7, 1.8);
            group.add(leftNostril);
            const rightNostril = new THREE.Mesh(nostrilGeometry, nostrilMaterial);
            rightNostril.position.set(0.4, 0.7, 1.8);
            group.add(rightNostril);

            const eyeGeometry = new THREE.SphereGeometry(0.2, 12, 12);
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.9, 2, 0.6);
            group.add(leftEye);
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.9, 2, 0.6);
            group.add(rightEye);

            const earGeometry = new THREE.ConeGeometry(0.4, 2.2, 8);
            const leftEar = new THREE.Mesh(earGeometry, bodyMaterial);
            leftEar.position.set(-0.8, 3.2, -0.2);
            leftEar.rotation.z = -Math.PI / 8;
            leftEar.castShadow = true;
            group.add(leftEar);
            const rightEar = new THREE.Mesh(earGeometry, bodyMaterial);
            rightEar.position.set(0.8, 3.2, -0.2);
            rightEar.rotation.z = Math.PI / 8;
            rightEar.castShadow = true;
            group.add(rightEar);
            
            const maneGeometry = new THREE.BoxGeometry(0.3, 1.5, 0.4);
            const mane = new THREE.Mesh(maneGeometry, maneMaterial);
            mane.position.set(0, 2.8, -0.5);
            mane.castShadow = true;
            group.add(mane);
            const scale = isBoss ? 1.5 : defaultScale;
            group.scale.set(scale, scale, scale);
            return group;
        }

        // 塵土特效
        class DustEffect {
            constructor(position) {
                const particleCount = 10;
                const particleMaterial = new THREE.MeshStandardMaterial({
                    color: 0x966932,
                    transparent: true,
                    opacity: 0.7
                });
                this.particles = new THREE.Group();
                for (let i = 0; i < particleCount; i++) {
                    const particleGeom = new THREE.SphereGeometry(Math.random() * 0.2 + 0.1, 8, 8);
                    const particle = new THREE.Mesh(particleGeom, particleMaterial);
                    particle.position.copy(position);
                    
                    const angle = Math.random() * Math.PI * 2;
                    const speed = Math.random() * 2 + 1;
                    particle.userData.velocity = new THREE.Vector3(
                        Math.cos(angle) * speed,
                        Math.random() * 2 + 2,
                        Math.sin(angle) * speed
                    );
                    this.particles.add(particle);
                }
                scene.add(this.particles);
                this.life = 1.0;
            }

            update(deltaTime) {
                this.life -= deltaTime * 2;
                this.particles.children.forEach(particle => {
                    particle.position.add(particle.userData.velocity.clone().multiplyScalar(deltaTime));
                    particle.userData.velocity.y -= 9.8 * deltaTime; // Gravity
                    particle.material.opacity = this.life;
                });

                if (this.life <= 0) {
                    scene.remove(this.particles);
                    return false; // Inactive
                }
                return true; // Active
            }
        }
        
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const deltaTime = clock.getDelta();
            controls.update();

            // 更新塵土特效
            dustEffects = dustEffects.filter(effect => effect.update(deltaTime));

            if (hammer) {
                raycaster.setFromCamera(pointer, camera);
                const groundPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
                const intersectPoint = new THREE.Vector3();
                raycaster.ray.intersectPlane(groundPlane, intersectPoint);
                
                // 揮動動畫
                if (isSwinging) {
                    swingProgress += deltaTime * 8;
                    const swingAngle = Math.sin(swingProgress * Math.PI) * (-Math.PI / 2);
                    hammer.rotation.x = swingAngle;

                    // 揮動到最低點
                    if (swingProgress >= 0.5 && swingProgress - deltaTime * 8 < 0.5) {
                         if (hammer.userData.didMiss) {
                            hammer.position.y -= 0.5; // 卡進地面
                            dustEffects.push(new DustEffect(intersectPoint));
                         }
                    }

                    if (swingProgress >= 1) {
                        isSwinging = false;
                        swingProgress = 0;
                        hammer.userData.didMiss = false;
                    }
                }
                 // 如果沒有在揮動，則讓槌子跟隨滑鼠
                if (!isSwinging) {
                    hammer.position.lerp(intersectPoint.clone().add(new THREE.Vector3(0, 1.5, 0)), 0.4);
                    hammer.lookAt(intersectPoint);
                }
            }
            
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onPointerMove(event) {
            pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
            pointer.y = - (event.clientY / window.innerHeight) * 2 + 1;
        }

        function onPointerDown(event) {
            if (!isGameRunning || isSwinging) return;
            
            isSwinging = true;
            swingProgress = 0;
            let didHit = false;

            raycaster.setFromCamera(pointer, camera);
            const intersects = raycaster.intersectObjects(scene.children, true);
            for (const intersect of intersects) {
                let obj = intersect.object;
                while(obj.parent && (obj.name !== "donkey" && obj.name !== "bossDonkey")) {
                    obj = obj.parent;
                }
                if ((obj.name === "donkey" || obj.name === "bossDonkey") && obj.userData.isUp) {
                    whack(obj);
                    didHit = true;
                    break;
                }
            }
            
            hammer.userData.didMiss = !didHit;
        }

        function startGame() {
            endGameModal.classList.add('hidden');
            if (isGameRunning) return;
            isGameRunning = true;
            isBossActive = false;
            score = 0;
            timeLeft = 60;
            scoreDisplay.textContent = score;
            timeLeftDisplay.textContent = timeLeft;
            startButton.classList.add('hidden');
            upgradeButton.classList.remove('hidden');
            
            resetAllMutations();
            updateUpgradeButtonState();
            restartAnimalTimer();

            gameTimerId = setInterval(countdown, 1000);
        }

        function restartAnimalTimer() {
            clearInterval(animalTimerId);
            if (!isBossActive && isGameRunning) {
                animalTimerId = setInterval(popAnimal, popInterval);
            }
        }
        
        function popAnimal() {
            if (!isGameRunning || isBossActive) return;
            const availableDonkeys = donkeys.filter(d => !d.userData.isUp);
            if (availableDonkeys.length === 0) return;
            const donkey = availableDonkeys[Math.floor(Math.random() * availableDonkeys.length)];
            
            if (isAdvancedModeActive && Math.random() < 0.4) {
                donkey.userData.isAdvanced = true;
                donkey.traverse(child => {
                    if(child.isMesh) child.material.color.set(0xC0C0C0);
                });
            }

            donkey.userData.isUp = true;
            donkey.position.y = -1;
            const popTime = Math.random() * popDurationMax + popDurationMin;
            donkey.userData.timeoutId = setTimeout(() => {
                if(donkey.userData.isUp){
                    donkey.position.y = -popHeight;
                    donkey.userData.isUp = false;
                    resetDonkeyAppearance(donkey);
                }
            }, popTime);
        }

        function applyMutation(mutationName) {
            resetAllMutations();
            mutationStatusDisplay.textContent = `變異: ${mutationName}`;

            switch (mutationName) {
                case '加速!':
                    popInterval = 700;
                    popDurationMin = 400;
                    popDurationMax = 500;
                    break;
                case '縮小!':
                    donkeys.forEach(donkey => {
                        const s = defaultScale * 0.6;
                        donkey.scale.set(s, s, s);
                    });
                    break;
                case '變色!':
                    donkeys.forEach(donkey => {
                        donkey.traverse(child => {
                            if (child.isMesh) {
                                child.material.color.set(Math.random() * 0xffffff);
                            }
                        });
                    });
                    break;
                case '騷味來襲!':
                    popBoss();
                    return; // popBoss handles its own timer logic
            }
            restartAnimalTimer();
        }

        function resetAllMutations() {
            mutationStatusDisplay.textContent = '等待變異...';
            clearInterval(animalTimerId);
            if (isBossActive) {
                clearTimeout(bossDonkey.userData.timeoutId);
                bossDonkey.position.y = -popHeight * 2;
                bossDonkey.userData.isUp = false;
                isBossActive = false;
            }
            popInterval = 1500;
            popDurationMin = 800;
            popDurationMax = 1000;
            donkeys.forEach(donkey => {
                resetDonkeyAppearance(donkey);
                donkey.scale.set(defaultScale, defaultScale, defaultScale);
            });
        }
        
        function popBoss() {
            if (!isGameRunning || isBossActive) return;
            isBossActive = true;
            clearInterval(animalTimerId);
            donkeys.forEach(d => {
                clearTimeout(d.userData.timeoutId);
                d.position.y = -popHeight;
                d.userData.isUp = false;
            });
            bossMessage.style.opacity = 1;
            setTimeout(() => { bossMessage.style.opacity = 0; }, 2000);
            const pos = holePositions[Math.floor(Math.random() * holePositions.length)];
            bossDonkey.position.copy(pos);
            bossDonkey.position.y = -1;
            bossDonkey.userData.isUp = true;
            bossDonkey.userData.hitsNeeded = 5;
            bossDonkey.userData.timeoutId = setTimeout(() => {
                if (bossDonkey.userData.isUp) {
                    resetAllMutations();
                    restartAnimalTimer();
                }
            }, 8000);
        }

        function whack(donkey) {
            if (donkey.name === "bossDonkey") {
                donkey.userData.hitsNeeded--;
                const originalColor = donkey.children[0].material.color.getHex();
                donkey.children.forEach(child => {
                    if (child.material) child.material.color.set(0xffffff);
                });
                setTimeout(() => {
                    donkey.children.forEach(child => {
                        if (child.material) child.material.color.set(originalColor);
                    });
                }, 100);
                if (donkey.userData.hitsNeeded <= 0) {
                    score *= 2;
                    clearTimeout(donkey.userData.timeoutId);
                    resetAllMutations();
                    restartAnimalTimer();
                }
            } else {
                 if (donkey.userData.isAdvanced) {
                     score += 10;
                 } else {
                     score += 3;
                 }
                 clearTimeout(donkey.userData.timeoutId);
                 donkey.position.y = -popHeight;
                 donkey.userData.isUp = false;
                 resetDonkeyAppearance(donkey);
            }
            scoreDisplay.textContent = score;
            scoreDisplay.classList.add('score-updated');
            setTimeout(() => scoreDisplay.classList.remove('score-updated'), 300);
            updateUpgradeButtonState();
        }

        function countdown() {
            timeLeft--;
            timeLeftDisplay.textContent = timeLeft;

            if ((60 - timeLeft) % 13 === 0 && timeLeft > 0 && timeLeft < 60) {
                const nextMutation = mutations[Math.floor(Math.random() * mutations.length)];
                applyMutation(nextMutation);
            }

            if (timeLeft <= 0) {
                endGame();
            }
        }

        function endGame() {
            clearInterval(gameTimerId);
            clearInterval(animalTimerId);
            clearTimeout(advancedModeTimeoutId);
            isGameRunning = false;
            resetAllMutations();
            
            donkeys.forEach(donkey => {
                clearTimeout(donkey.userData.timeoutId);
                donkey.position.y = -popHeight;
                donkey.userData.isUp = false;
            });
            
            upgradeButton.classList.add('hidden');
            finalScoreDisplay.textContent = score;
            endGameModal.classList.remove('hidden');
            startButton.classList.remove('hidden');
        }

        function buyUpgrade() {
            if (score >= UPGRADE_COST && !isAdvancedModeActive && isGameRunning) {
                score -= UPGRADE_COST;
                scoreDisplay.textContent = score;
                isAdvancedModeActive = true;
                
                mutationStatusDisplay.textContent = '高級驢子時間!';
                updateUpgradeButtonState();

                advancedModeTimeoutId = setTimeout(() => {
                    isAdvancedModeActive = false;
                    mutationStatusDisplay.textContent = '等待變異...';
                    updateUpgradeButtonState();
                }, 10000); // 持續 10 秒
            }
        }

        function updateUpgradeButtonState() {
            if (!isGameRunning) return;
            upgradeButton.disabled = score < UPGRADE_COST || isAdvancedModeActive || isBossActive;
        }

        function resetDonkeyAppearance(donkey) {
             if (donkey.userData.isAdvanced) {
                donkey.userData.isAdvanced = false;
                donkey.traverse(child => {
                    if (child.isMesh) {
                        child.material.color.copy(child.material.userData.originalColor);
                    }
                });
            }
        }

        init();
    </script>
</body>
</html>

